// Code generated by sqlc. DO NOT EDIT.
// source: snow.sql

package db

import (
	"context"
)

const createSnow = `-- name: CreateSnow :one
INSERT INTO snow (
  substanse_name,
  date_of_sampling,
  number_of_sample,
  concentration,
  unit_of_measure,
  location,
  longitude,
  latitude,
  source_of_emission,
  license_area,
  num_of_license,
  company,
  method_of_determ,
  laboratory
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, substanse_name, date_of_sampling, number_of_sample, concentration, unit_of_measure, location, longitude, latitude, source_of_emission, license_area, num_of_license, company, method_of_determ, laboratory, created_at
`

type CreateSnowParams struct {
	SubstanseName    string  `json:"substanse_name"`
	DateOfSampling   string  `json:"date_of_sampling"`
	NumberOfSample   string  `json:"number_of_sample"`
	Concentration    float32 `json:"concentration"`
	UnitOfMeasure    string  `json:"unit_of_measure"`
	Location         string  `json:"location"`
	Longitude        string  `json:"longitude"`
	Latitude         string  `json:"latitude"`
	SourceOfEmission string  `json:"source_of_emission"`
	LicenseArea      string  `json:"license_area"`
	NumOfLicense     string  `json:"num_of_license"`
	Company          string  `json:"company"`
	MethodOfDeterm   string  `json:"method_of_determ"`
	Laboratory       string  `json:"laboratory"`
}

func (q *Queries) CreateSnow(ctx context.Context, arg CreateSnowParams) (Snow, error) {
	row := q.db.QueryRowContext(ctx, createSnow,
		arg.SubstanseName,
		arg.DateOfSampling,
		arg.NumberOfSample,
		arg.Concentration,
		arg.UnitOfMeasure,
		arg.Location,
		arg.Longitude,
		arg.Latitude,
		arg.SourceOfEmission,
		arg.LicenseArea,
		arg.NumOfLicense,
		arg.Company,
		arg.MethodOfDeterm,
		arg.Laboratory,
	)
	var i Snow
	err := row.Scan(
		&i.ID,
		&i.SubstanseName,
		&i.DateOfSampling,
		&i.NumberOfSample,
		&i.Concentration,
		&i.UnitOfMeasure,
		&i.Location,
		&i.Longitude,
		&i.Latitude,
		&i.SourceOfEmission,
		&i.LicenseArea,
		&i.NumOfLicense,
		&i.Company,
		&i.MethodOfDeterm,
		&i.Laboratory,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSnow = `-- name: DeleteSnow :exec
DELETE FROM snow
WHERE id = $1
`

func (q *Queries) DeleteSnow(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSnow, id)
	return err
}

const getSnow = `-- name: GetSnow :one
SELECT id, substanse_name, date_of_sampling, number_of_sample, concentration, unit_of_measure, location, longitude, latitude, source_of_emission, license_area, num_of_license, company, method_of_determ, laboratory, created_at FROM snow
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSnow(ctx context.Context, id int64) (Snow, error) {
	row := q.db.QueryRowContext(ctx, getSnow, id)
	var i Snow
	err := row.Scan(
		&i.ID,
		&i.SubstanseName,
		&i.DateOfSampling,
		&i.NumberOfSample,
		&i.Concentration,
		&i.UnitOfMeasure,
		&i.Location,
		&i.Longitude,
		&i.Latitude,
		&i.SourceOfEmission,
		&i.LicenseArea,
		&i.NumOfLicense,
		&i.Company,
		&i.MethodOfDeterm,
		&i.Laboratory,
		&i.CreatedAt,
	)
	return i, err
}

const listSnow = `-- name: ListSnow :many
SELECT id, substanse_name, date_of_sampling, number_of_sample, concentration, unit_of_measure, location, longitude, latitude, source_of_emission, license_area, num_of_license, company, method_of_determ, laboratory, created_at FROM snow
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListSnowParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSnow(ctx context.Context, arg ListSnowParams) ([]Snow, error) {
	rows, err := q.db.QueryContext(ctx, listSnow, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Snow{}
	for rows.Next() {
		var i Snow
		if err := rows.Scan(
			&i.ID,
			&i.SubstanseName,
			&i.DateOfSampling,
			&i.NumberOfSample,
			&i.Concentration,
			&i.UnitOfMeasure,
			&i.Location,
			&i.Longitude,
			&i.Latitude,
			&i.SourceOfEmission,
			&i.LicenseArea,
			&i.NumOfLicense,
			&i.Company,
			&i.MethodOfDeterm,
			&i.Laboratory,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSnow = `-- name: UpdateSnow :exec
UPDATE snow
SET substanse_name = $2
WHERE id = $1
`

type UpdateSnowParams struct {
	ID            int64  `json:"id"`
	SubstanseName string `json:"substanse_name"`
}

func (q *Queries) UpdateSnow(ctx context.Context, arg UpdateSnowParams) error {
	_, err := q.db.ExecContext(ctx, updateSnow, arg.ID, arg.SubstanseName)
	return err
}
