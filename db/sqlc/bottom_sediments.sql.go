// Code generated by sqlc. DO NOT EDIT.
// source: bottom_sediments.sql

package db

import (
	"context"
)

const createBottomSediments = `-- name: CreateBottomSediments :one
INSERT INTO bottom_sediments (
  substanse_name,
  date_of_sampling,
  number_of_sample,
  type_of_sediments,
  concentration,
  unit_of_measure,
  location,
  longitude,
  latitude,
  reservoir,
  license_area,
  num_of_license,
  company,
  method_of_determ,
  laboratory
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
)
RETURNING id, substanse_name, date_of_sampling, number_of_sample, type_of_sediments, concentration, unit_of_measure, location, longitude, latitude, reservoir, license_area, num_of_license, company, method_of_determ, laboratory, created_at
`

type CreateBottomSedimentsParams struct {
	SubstanseName   string  `json:"substanse_name"`
	DateOfSampling  string  `json:"date_of_sampling"`
	NumberOfSample  string  `json:"number_of_sample"`
	TypeOfSediments string  `json:"type_of_sediments"`
	Concentration   float32 `json:"concentration"`
	UnitOfMeasure   string  `json:"unit_of_measure"`
	Location        string  `json:"location"`
	Longitude       string  `json:"longitude"`
	Latitude        string  `json:"latitude"`
	Reservoir       string  `json:"reservoir"`
	LicenseArea     string  `json:"license_area"`
	NumOfLicense    string  `json:"num_of_license"`
	Company         string  `json:"company"`
	MethodOfDeterm  string  `json:"method_of_determ"`
	Laboratory      string  `json:"laboratory"`
}

func (q *Queries) CreateBottomSediments(ctx context.Context, arg CreateBottomSedimentsParams) (BottomSediment, error) {
	row := q.db.QueryRowContext(ctx, createBottomSediments,
		arg.SubstanseName,
		arg.DateOfSampling,
		arg.NumberOfSample,
		arg.TypeOfSediments,
		arg.Concentration,
		arg.UnitOfMeasure,
		arg.Location,
		arg.Longitude,
		arg.Latitude,
		arg.Reservoir,
		arg.LicenseArea,
		arg.NumOfLicense,
		arg.Company,
		arg.MethodOfDeterm,
		arg.Laboratory,
	)
	var i BottomSediment
	err := row.Scan(
		&i.ID,
		&i.SubstanseName,
		&i.DateOfSampling,
		&i.NumberOfSample,
		&i.TypeOfSediments,
		&i.Concentration,
		&i.UnitOfMeasure,
		&i.Location,
		&i.Longitude,
		&i.Latitude,
		&i.Reservoir,
		&i.LicenseArea,
		&i.NumOfLicense,
		&i.Company,
		&i.MethodOfDeterm,
		&i.Laboratory,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBottomSediments = `-- name: DeleteBottomSediments :exec
DELETE FROM bottom_sediments
WHERE id = $1
`

func (q *Queries) DeleteBottomSediments(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBottomSediments, id)
	return err
}

const getBottomSediments = `-- name: GetBottomSediments :one
SELECT id, substanse_name, date_of_sampling, number_of_sample, type_of_sediments, concentration, unit_of_measure, location, longitude, latitude, reservoir, license_area, num_of_license, company, method_of_determ, laboratory, created_at FROM bottom_sediments
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetBottomSediments(ctx context.Context, id int64) (BottomSediment, error) {
	row := q.db.QueryRowContext(ctx, getBottomSediments, id)
	var i BottomSediment
	err := row.Scan(
		&i.ID,
		&i.SubstanseName,
		&i.DateOfSampling,
		&i.NumberOfSample,
		&i.TypeOfSediments,
		&i.Concentration,
		&i.UnitOfMeasure,
		&i.Location,
		&i.Longitude,
		&i.Latitude,
		&i.Reservoir,
		&i.LicenseArea,
		&i.NumOfLicense,
		&i.Company,
		&i.MethodOfDeterm,
		&i.Laboratory,
		&i.CreatedAt,
	)
	return i, err
}

const listBottomSediments = `-- name: ListBottomSediments :many
SELECT id, substanse_name, date_of_sampling, number_of_sample, type_of_sediments, concentration, unit_of_measure, location, longitude, latitude, reservoir, license_area, num_of_license, company, method_of_determ, laboratory, created_at FROM bottom_sediments
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListBottomSedimentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBottomSediments(ctx context.Context, arg ListBottomSedimentsParams) ([]BottomSediment, error) {
	rows, err := q.db.QueryContext(ctx, listBottomSediments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BottomSediment{}
	for rows.Next() {
		var i BottomSediment
		if err := rows.Scan(
			&i.ID,
			&i.SubstanseName,
			&i.DateOfSampling,
			&i.NumberOfSample,
			&i.TypeOfSediments,
			&i.Concentration,
			&i.UnitOfMeasure,
			&i.Location,
			&i.Longitude,
			&i.Latitude,
			&i.Reservoir,
			&i.LicenseArea,
			&i.NumOfLicense,
			&i.Company,
			&i.MethodOfDeterm,
			&i.Laboratory,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBottomSediments = `-- name: UpdateBottomSediments :exec
UPDATE bottom_sediments
SET substanse_name = $2
WHERE id = $1
`

type UpdateBottomSedimentsParams struct {
	ID            int64  `json:"id"`
	SubstanseName string `json:"substanse_name"`
}

func (q *Queries) UpdateBottomSediments(ctx context.Context, arg UpdateBottomSedimentsParams) error {
	_, err := q.db.ExecContext(ctx, updateBottomSediments, arg.ID, arg.SubstanseName)
	return err
}
