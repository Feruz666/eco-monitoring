// Code generated by sqlc. DO NOT EDIT.
// source: surface_water.sql

package db

import (
	"context"
)

const createSurfaceWater = `-- name: CreateSurfaceWater :one
INSERT INTO surface_water (
  substanse_name,
  date_of_sampling,
  number_of_sample,
  concentration,
  unit_of_measure,
  location,
  longitude,
  latitude,
  reservoir,
  license_area,
  num_of_license,
  company,
  method_of_determ,
  laboratory
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, substanse_name, date_of_sampling, number_of_sample, concentration, unit_of_measure, location, longitude, latitude, reservoir, license_area, num_of_license, company, method_of_determ, laboratory, created_at
`

type CreateSurfaceWaterParams struct {
	SubstanseName  string  `json:"substanse_name"`
	DateOfSampling string  `json:"date_of_sampling"`
	NumberOfSample string  `json:"number_of_sample"`
	Concentration  float32 `json:"concentration"`
	UnitOfMeasure  string  `json:"unit_of_measure"`
	Location       string  `json:"location"`
	Longitude      string  `json:"longitude"`
	Latitude       string  `json:"latitude"`
	Reservoir      string  `json:"reservoir"`
	LicenseArea    string  `json:"license_area"`
	NumOfLicense   string  `json:"num_of_license"`
	Company        string  `json:"company"`
	MethodOfDeterm string  `json:"method_of_determ"`
	Laboratory     string  `json:"laboratory"`
}

func (q *Queries) CreateSurfaceWater(ctx context.Context, arg CreateSurfaceWaterParams) (SurfaceWater, error) {
	row := q.db.QueryRowContext(ctx, createSurfaceWater,
		arg.SubstanseName,
		arg.DateOfSampling,
		arg.NumberOfSample,
		arg.Concentration,
		arg.UnitOfMeasure,
		arg.Location,
		arg.Longitude,
		arg.Latitude,
		arg.Reservoir,
		arg.LicenseArea,
		arg.NumOfLicense,
		arg.Company,
		arg.MethodOfDeterm,
		arg.Laboratory,
	)
	var i SurfaceWater
	err := row.Scan(
		&i.ID,
		&i.SubstanseName,
		&i.DateOfSampling,
		&i.NumberOfSample,
		&i.Concentration,
		&i.UnitOfMeasure,
		&i.Location,
		&i.Longitude,
		&i.Latitude,
		&i.Reservoir,
		&i.LicenseArea,
		&i.NumOfLicense,
		&i.Company,
		&i.MethodOfDeterm,
		&i.Laboratory,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSurfaceWater = `-- name: DeleteSurfaceWater :exec
DELETE FROM surface_water
WHERE id = $1
`

func (q *Queries) DeleteSurfaceWater(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSurfaceWater, id)
	return err
}

const getSurfaceWater = `-- name: GetSurfaceWater :one
SELECT id, substanse_name, date_of_sampling, number_of_sample, concentration, unit_of_measure, location, longitude, latitude, reservoir, license_area, num_of_license, company, method_of_determ, laboratory, created_at FROM surface_water
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSurfaceWater(ctx context.Context, id int64) (SurfaceWater, error) {
	row := q.db.QueryRowContext(ctx, getSurfaceWater, id)
	var i SurfaceWater
	err := row.Scan(
		&i.ID,
		&i.SubstanseName,
		&i.DateOfSampling,
		&i.NumberOfSample,
		&i.Concentration,
		&i.UnitOfMeasure,
		&i.Location,
		&i.Longitude,
		&i.Latitude,
		&i.Reservoir,
		&i.LicenseArea,
		&i.NumOfLicense,
		&i.Company,
		&i.MethodOfDeterm,
		&i.Laboratory,
		&i.CreatedAt,
	)
	return i, err
}

const listSurfaceWater = `-- name: ListSurfaceWater :many
SELECT id, substanse_name, date_of_sampling, number_of_sample, concentration, unit_of_measure, location, longitude, latitude, reservoir, license_area, num_of_license, company, method_of_determ, laboratory, created_at FROM surface_water
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListSurfaceWaterParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSurfaceWater(ctx context.Context, arg ListSurfaceWaterParams) ([]SurfaceWater, error) {
	rows, err := q.db.QueryContext(ctx, listSurfaceWater, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurfaceWater{}
	for rows.Next() {
		var i SurfaceWater
		if err := rows.Scan(
			&i.ID,
			&i.SubstanseName,
			&i.DateOfSampling,
			&i.NumberOfSample,
			&i.Concentration,
			&i.UnitOfMeasure,
			&i.Location,
			&i.Longitude,
			&i.Latitude,
			&i.Reservoir,
			&i.LicenseArea,
			&i.NumOfLicense,
			&i.Company,
			&i.MethodOfDeterm,
			&i.Laboratory,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSurfaceWater = `-- name: UpdateSurfaceWater :exec
UPDATE surface_water
SET substanse_name = $2
WHERE id = $1
`

type UpdateSurfaceWaterParams struct {
	ID            int64  `json:"id"`
	SubstanseName string `json:"substanse_name"`
}

func (q *Queries) UpdateSurfaceWater(ctx context.Context, arg UpdateSurfaceWaterParams) error {
	_, err := q.db.ExecContext(ctx, updateSurfaceWater, arg.ID, arg.SubstanseName)
	return err
}
