// Code generated by sqlc. DO NOT EDIT.
// source: soil.sql

package db

import (
	"context"
)

const createSoil = `-- name: CreateSoil :one
INSERT INTO soil (
  substanse_name,
  date_of_sampling,
  number_of_sample,
  soil_subtype,
  concentration,
  unit_of_measure,
  location,
  longitude,
  latitude,
  license_area,
  num_of_license,
  company,
  method_of_determ,
  laboratory
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, substanse_name, date_of_sampling, number_of_sample, soil_subtype, concentration, unit_of_measure, location, longitude, latitude, license_area, num_of_license, company, method_of_determ, laboratory, created_at
`

type CreateSoilParams struct {
	SubstanseName  string  `json:"substanse_name"`
	DateOfSampling string  `json:"date_of_sampling"`
	NumberOfSample string  `json:"number_of_sample"`
	SoilSubtype    string  `json:"soil_subtype"`
	Concentration  float32 `json:"concentration"`
	UnitOfMeasure  string  `json:"unit_of_measure"`
	Location       string  `json:"location"`
	Longitude      string  `json:"longitude"`
	Latitude       string  `json:"latitude"`
	LicenseArea    string  `json:"license_area"`
	NumOfLicense   string  `json:"num_of_license"`
	Company        string  `json:"company"`
	MethodOfDeterm string  `json:"method_of_determ"`
	Laboratory     string  `json:"laboratory"`
}

func (q *Queries) CreateSoil(ctx context.Context, arg CreateSoilParams) (Soil, error) {
	row := q.db.QueryRowContext(ctx, createSoil,
		arg.SubstanseName,
		arg.DateOfSampling,
		arg.NumberOfSample,
		arg.SoilSubtype,
		arg.Concentration,
		arg.UnitOfMeasure,
		arg.Location,
		arg.Longitude,
		arg.Latitude,
		arg.LicenseArea,
		arg.NumOfLicense,
		arg.Company,
		arg.MethodOfDeterm,
		arg.Laboratory,
	)
	var i Soil
	err := row.Scan(
		&i.ID,
		&i.SubstanseName,
		&i.DateOfSampling,
		&i.NumberOfSample,
		&i.SoilSubtype,
		&i.Concentration,
		&i.UnitOfMeasure,
		&i.Location,
		&i.Longitude,
		&i.Latitude,
		&i.LicenseArea,
		&i.NumOfLicense,
		&i.Company,
		&i.MethodOfDeterm,
		&i.Laboratory,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSoil = `-- name: DeleteSoil :exec
DELETE FROM soil
WHERE id = $1
`

func (q *Queries) DeleteSoil(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSoil, id)
	return err
}

const getSoil = `-- name: GetSoil :one
SELECT id, substanse_name, date_of_sampling, number_of_sample, soil_subtype, concentration, unit_of_measure, location, longitude, latitude, license_area, num_of_license, company, method_of_determ, laboratory, created_at FROM soil
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSoil(ctx context.Context, id int64) (Soil, error) {
	row := q.db.QueryRowContext(ctx, getSoil, id)
	var i Soil
	err := row.Scan(
		&i.ID,
		&i.SubstanseName,
		&i.DateOfSampling,
		&i.NumberOfSample,
		&i.SoilSubtype,
		&i.Concentration,
		&i.UnitOfMeasure,
		&i.Location,
		&i.Longitude,
		&i.Latitude,
		&i.LicenseArea,
		&i.NumOfLicense,
		&i.Company,
		&i.MethodOfDeterm,
		&i.Laboratory,
		&i.CreatedAt,
	)
	return i, err
}

const listSoil = `-- name: ListSoil :many
SELECT id, substanse_name, date_of_sampling, number_of_sample, soil_subtype, concentration, unit_of_measure, location, longitude, latitude, license_area, num_of_license, company, method_of_determ, laboratory, created_at FROM soil
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListSoilParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSoil(ctx context.Context, arg ListSoilParams) ([]Soil, error) {
	rows, err := q.db.QueryContext(ctx, listSoil, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Soil{}
	for rows.Next() {
		var i Soil
		if err := rows.Scan(
			&i.ID,
			&i.SubstanseName,
			&i.DateOfSampling,
			&i.NumberOfSample,
			&i.SoilSubtype,
			&i.Concentration,
			&i.UnitOfMeasure,
			&i.Location,
			&i.Longitude,
			&i.Latitude,
			&i.LicenseArea,
			&i.NumOfLicense,
			&i.Company,
			&i.MethodOfDeterm,
			&i.Laboratory,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSoil = `-- name: UpdateSoil :exec
UPDATE soil
SET substanse_name = $2
WHERE id = $1
`

type UpdateSoilParams struct {
	ID            int64  `json:"id"`
	SubstanseName string `json:"substanse_name"`
}

func (q *Queries) UpdateSoil(ctx context.Context, arg UpdateSoilParams) error {
	_, err := q.db.ExecContext(ctx, updateSoil, arg.ID, arg.SubstanseName)
	return err
}
